{"meta":{"title":"iguigui的博客","subtitle":"","description":"iguigui的博客","author":"我的龟龟","url":"https://btreenewbee.github.io","root":"/"},"pages":[],"posts":[{"title":"写个带图片的","slug":"写个带图片的","date":"2022-02-02T16:41:25.000Z","updated":"2022-02-02T17:59:18.748Z","comments":true,"path":"2022/02/03/写个带图片的/","link":"","permalink":"https://btreenewbee.github.io/2022/02/03/%E5%86%99%E4%B8%AA%E5%B8%A6%E5%9B%BE%E7%89%87%E7%9A%84/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"多写点少写点多少写点","slug":"多写点少写点多少写点","date":"2022-02-02T16:15:44.000Z","updated":"2022-02-02T16:15:44.206Z","comments":true,"path":"2022/02/03/多写点少写点多少写点/","link":"","permalink":"https://btreenewbee.github.io/2022/02/03/%E5%A4%9A%E5%86%99%E7%82%B9%E5%B0%91%E5%86%99%E7%82%B9%E5%A4%9A%E5%B0%91%E5%86%99%E7%82%B9/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"汇编笔记基本版","slug":"汇编笔记","date":"2021-09-04T10:51:18.000Z","updated":"2021-09-04T10:51:18.715Z","comments":true,"path":"2021/09/04/汇编笔记/","link":"","permalink":"https://btreenewbee.github.io/2021/09/04/%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"写个测试文章","slug":"写个测试文章","date":"2021-03-24T15:39:24.000Z","updated":"2021-03-25T16:56:15.382Z","comments":true,"path":"2021/03/24/写个测试文章/","link":"","permalink":"https://btreenewbee.github.io/2021/03/24/%E5%86%99%E4%B8%AA%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/","excerpt":"","text":"如何写一个排版优雅的文章？12345678910111213//这里是一个代码块 private fun reflushMarketInfo() &#123; val url = &quot;https://fxhapi.feixiaohao.com/public/v1/ticker?limit=1000&quot; val get = HttpUtil.get(url) if (get == null) &#123; return &#125; var sarray = Gson().fromJson&lt;List&lt;MarketInfo&gt;&gt;(get) val timestamp = sarray[0].last_updated * 1000 val ofEpochSecond = LocalDateTime.ofEpochSecond(timestamp, 0, ZoneOffset.ofHours(8)) lastUpdateTime = ofEpochSecond.format(pattern) markets = sarray.associateBy(&#123; it.symbol &#125;, &#123; it &#125;) &#125;","categories":[],"tags":[]},{"title":"HTTPS中的S意味着什么?","slug":"HTTPS中的S意味着什么","date":"2021-02-02T18:11:26.000Z","updated":"2022-02-11T15:44:50.745Z","comments":true,"path":"2021/02/03/HTTPS中的S意味着什么/","link":"","permalink":"https://btreenewbee.github.io/2021/02/03/HTTPS%E4%B8%AD%E7%9A%84S%E6%84%8F%E5%91%B3%E7%9D%80%E4%BB%80%E4%B9%88/","excerpt":"","text":"HTTPS试图解决什么问题？HTTP作为使用最广泛的应用层协议，由于是全明文传输，可以随意被人截获、修改，存在巨大的安全隐患，为此就需要一种办法来确保安全通信。 这种方式就是在HTTP的基础上增加一层SSL（或称TLS）进行加强。 安全通信的基本特性 机密性。这个是最基础的对安全通信的理解，即应该有且仅有发送方和希望的接收方能够理解传输信息的内容。 完整性。信息在传输过程中应该未被改变，完整可靠。 端点鉴别。这一点可能比较难以理解，但是思考一下一种情况：现在你向网站发起请求，你如何判定你是向真正的网站在请求，而不是一个假网站？又或者是有一个人伪装成服务器在跟你通信，他又伪装成你去跟真正的服务器通信以此来窃取你的信息？服务器又如何肯定请求来自于真正的你？ 这就是我们的需求分析环节，接下来我们将描述如何解决这些问题。 实现我们三个目标的核心：密码学事实上HTTPS是完全是现代密码学的成果，我们不可能在不理解基本密码学的情况下理解HTTPS。 对称加密首先我们有一段希望发送的原始信息，这叫明文，我们使用加密算法将你的明文转换成一个无法理解的密文进行传输，接收方接收到以后，重新使用解密算法将密文转换成可理解的明文。 看起来非常简单是不是？看上去我们只需要把加解密算法藏好就可以了？ 但是这里存在一个很明显的问题：HTTPS，或者说SSL/TLS是一个公开标准化的技术，每个人都可以随意使用，实现他，你用的加密方法别人也知道。（也正是开放开源才有了现代互联网的繁荣，只要遵循协议都可以加入互联网） 既然加解密编码的方法是公开的，那么肯定就还有什么东西可以让别人知道方法也无法解密数据。这就是密钥，就好像现实生活中的锁的结构其实是公开的，大家买回家的都一样，但是钥匙是自己的。 在进行了以上内容的铺垫以后，现在可以引出对称加密的概念了：通信双方均使用同样的密钥进行加解密，并且这个密钥是只有通信双方知道的。 典型的对称加密算法有DES，3DES，AES等。 这就是人类已经使用了两千多年的最经典的加密方式，不难看出来，这个体系的核心就是双方需要先约定好一个有且仅有双方知道的密钥，而约定这一步就需要进行通信。现实生活中我们可能会搞成线下碰个头之类的办法，为了防止窃听偷拍还要选择公共澡堂。 但是在网络世界中，通信双方可能从未见过面，几乎不存在提前约定或者在非网络环境下通信的可能，这种情况下你要如何进行加密通信？没有共同的密钥就无法进行安全的对称加密通信，而不进行加密通信双方就无法安全地约定密钥，这不就成没有工作经验就找不到工作的死循环了么？ 很明显我们需要一种更优雅的加密方式来跳出死循环。 Differ-Hellman密钥交换算法与公开密钥加密算法如何实现在公开的不安全的网络中进行安全的信息交换传输？ 我们首先来看Differ-Hellman密钥交换算法。 Differ-Hellman密钥交换算法此算法一般应用于在公开的不安全的网络中进行密钥协商交换，从而可以进行对称加密通信。 计算过程如下： alice向bob传递三个参数：素数p，整数g，以及根据自己内部的隐藏参数a计算出来的A。 bob根据接受到的三个参数，用自己随机选择的隐藏参数b计算返回B，同时这一步自己也算出来K。 Alice接收B，计算得到K。 以下是一个简单的计算过程： 1. 我们取素数p为97，整数g为5，隐藏参数a为36，隐藏参数b为58。 2. Alice进行计算：A = 5 ^ 36 mod 97 = 50，则向Bob传递三个参数：p = 97，g = 5，A = 50。 3. Bob进行计算：K = 50 ^ 58 mod 97 = 75，得到密钥75，B = 5 ^ 58 mod 97 = 44，回传给Alice。 4. Alice进行计算：K = 44 ^ 36 mod 97 = 75，得到密钥75，交换完成。 以及一个我自己写的简单的代码例子 Differ-Hellman交换的简单Java例子 在整个交换过程中，暴露出来的信息只有p = 97，g = 5，A = 50，B = 44，最终双方协商出来了密钥K = 75。 在这种情况下，只知道四个公开参数，只有计算离散对数算出来隐藏参数a和b才能破解出真正的密钥k = 75。 实际应用中一般会选择极大的g和p（几百位以上）防止暴力破解。 公开密钥加密算法（RSA）也称为非对称加密，特点是存在一个公钥一个私钥，用公钥加密，用私钥解密。 RSA的基本计算过程： 选择两个素数p和q，实践中推荐选个大的。 计算 n = p * q 和 z = (p - 1)*(q - 1)。 找一个小于n的数值e，与z无公因数。 求一个数d，使得 ed mod z = 1。 则公钥是一对数（n,e），私钥是一对数（n,d）。 m为明文，则密文 c = m ^ e mod n。 c为密文，则明文 m = c ^ d mod n。 一个更具体的例子 一个简单的RSA小Demo，JAVA实现 RSA的安全性依赖于对公开的数字n的分解，中间人可以获取到你的公钥（n,e），想找到d就必须分解n，一般推荐长度大于2048位。 有了非对称加密算法，就可以实现Alice给Bob发送一段公钥（这就是为什么叫公钥，公开的），Bob把想发送的内容进行公钥加密，回传给Alice，Alice再使用私钥解密。 看上去非常美好？这还要对称加密干嘛对吧，不用困难地想办法安全交换密钥了就很舒服。 实际上RSA的性能平均比DES低2-3个数量级，差个几倍可能还能拿机器顶一下，差几个数量级正常人都不会想全用RSA来进行通信。 聪明的你肯定也想到了，拿RSA来交换密钥不就行了，交换完密钥后面用DES，性能也有了，安全性也有了——事实上SSL/TLS就是这么干的。 散列函数什么是散列函数呢？就是我们平时最常见的哈希。 其特点有： 给定任意输入信息m，输出一个固定长度的信息是很简单的。 在这种函数上，想找到两个不同的输入m，却具有相同输出是很困难的。 无法从输出反推输入m，也称为单向性。 雪崩效应：输入发生微小的改变也可能导致输出的巨大变化。 具体来讲，例如Java中的hashcode()方法，返回值是int，输入就是对象自己，输出就永远是4byte的一个定长信息。 例如MD5，你可以对任何信息进行MD5运算，最后输出都是32byte。 再次强调一下，MD5不是加密，是散列。（我甚至看到有博客把MD5和SHA1叫做对称加密的！） 由于散列函数的输入范围是无穷大，而输出范围固定，所以必然存在无穷多个输入拥有相同的输出（也就是哈希碰撞），一般来讲都是通过增大输出范围来提高碰撞难度。 散列函数一般用于数据完整性鉴定，看了散列函数的特点想必不难理解。 SSL\\TLS的简单实现接下来进入SSL\\TLS的实现原理简述，因为整个SSL协议非常复杂，很难描述所有的细节过程，但是我尽量保证核心流程和功能描述完整。 前置准备工作 服务商S向CA证书机构提交自己的公钥、域名等信息，申请认证，私钥自己藏好，绝对不能泄露！ CA机构将通过各种方式（线上如文件校验、DNS校验、邮件校验，线下如验证组织机构是否真实存在等等）验证申请者的真实性（验证级别越高、签发的证书越高级，费用越高，因为CA机构是要负责的）。 审核通过，CA机构将签发证书，证书包含以下内容：服务商S的公钥、服务商S的信息、证书相关信息等，最重要的是包含一个数字签名。 数字签名的产生方式：对明文信息按照规则组合，然后进行散列运算得到一个哈希值，再使用CA机构的私钥对哈希值进行加密，最终得到签名。此步确保了两件事情：服务商信息的完整性（通过散列实现）以及确保了这个信息是经过CA机构认证的（CA机构用自己的私钥加密，而这个私钥是被CA机构严格安全保护的，核心思想是，如果有一串信息，只能用这个CA机构的公钥解密，那么说明必定是这个CA机构用私钥加密出来的，也就可以证明这串信息必然是这个CA机构生成的，这就叫数字签名）。 服务商S拿到证书，连同自己的私钥，一起部署在服务器上。 应用过程 客户端C向服务器S发起请求，也可以称为CilentHello，包含SSL版本等信息。 服务器S返回SSL版本信息、随机数等，最重要的是返回了证书文件，客户端C使用对应CA机构的公钥对证书签名进行解密（CA机构的公钥都是广泛公开的，浏览器和操作系统会内置），这一步可能会需要层层向上验证，因为证书的签发机构可能并不是根CA，得到一个哈希值（也就是CA机构签发的时候算的哈希值）。这一步如果没有找到证书文件的公钥，则证书可能无效；如果证书文件记录的域名与你访问的不一致，则说明证书被冒用；这一步还需要进行证书是否被吊销的验证(CRL+OCSP验证)。 证书与访问的域名不一致，证书可能被冒用 没有找到CA机构的公钥无法验证信息是否真实有效 客户端C同时对服务器S返回证书文件中的明文信息进行散列运算（就跟CA机构做的一样），得到一个哈希值。 比较两个哈希值是否一致，即可确认明文信息是否未被篡改，换句话说也就可以确认服务器S的这份证书是经过了CA机构认证可信的，服务器S是真实可靠的。 客户端C与服务器S协商加密方式、随机数等信息。 客户端C使用证书中的公钥加密一个随机的对称密钥，返回给服务器S，服务器S使用自己的私钥进行解密，双方完成通信密钥交换。（这一步其实还有一个重要的鉴别密钥，用于给报文签名来防止篡改保证完整性） 接下来就是正常的业务数据交互了，双方将使用交换好的对称密钥和鉴别密钥确保通信中的完整性和机密性。 重新回头去看我们要实现的目标：机密性、完整性、端点鉴别，机密性我们通过对称加密实现，而为了能约定出一个对称密钥，我们使用不对称加密来进行密钥交换；完整性我们通过数字签名 + 鉴别密钥实现；最后端点鉴别这一步，通过CA机构认证、加签，再用内置的CA机构公钥解密实现。 HTTPS带来了什么问题？任何技术从来都不能只看他好而不去思考他的代价以及副作用，事实上几乎任何新技术都有自己的成本。 认证与部署成本SSL\\TLS的证书，认证、部署都需要时间精力，高级别的还要昂贵的认证费用，相比之前HTTP的成本，对于小公司小创业团队来讲这也是不可忽视的。 当然现在也出现了免费的证书，为大家提供了一种选择。 首屏响应时长HTTP只需要进行三次TCP握手即可完成连接，之后就是纯应用层的操作了，可以认为只需要一次RTT延迟。 而HTTPS就不一样了，最极端的情况下会需要7次RTT延迟的时间才能进入应用层数据交互，包含HTTP 302转HTTPS、密钥交换等，更糟糕的是证书吊销检查这一步，还可能需要CA域名解析、CA域名握手、OCSP验证请求响应，这里就能吃掉3次RTT，如果CA机构的服务器带宽和链路质量不高，你的服务器带宽链路好也没用。强烈建议选择大厂的CA认证，选择靠近自己消费市场的CA机构，不要盲目选择机构。 服务器与客户端的性能和带宽消耗RSA加密解密的性能消耗一直是系统的瓶颈，平均RSA都比DES慢2-3个数量级，就算是握手交换使用，计算压力也很大，经常需要增加部署多台机器进行负担。 同时数据经过了加密，数据带宽占用也会增大。 私钥管理成本由于需要高可用以及考虑到RSA的计算压力，运维需要把私钥和证书部署在大量机器上做负载均衡，而私钥是非常关键和重要的东西，泄露了就需要吊销证书、重新申请、重新部署，这就为管理运维带来了巨大的麻烦，以至于需要弄出一套专门的私钥管理工具。","categories":[],"tags":[{"name":"SSL\\TLS","slug":"SSL-TLS","permalink":"https://btreenewbee.github.io/tags/SSL-TLS/"},{"name":"HTTPS","slug":"HTTPS","permalink":"https://btreenewbee.github.io/tags/HTTPS/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://btreenewbee.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"密码学","slug":"密码学","permalink":"https://btreenewbee.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]},{"title":"我在写什么","slug":"多写点少写点多少写点 - 副本","date":"2021-02-02T16:15:44.000Z","updated":"2022-02-02T16:21:16.963Z","comments":true,"path":"2021/02/03/多写点少写点多少写点 - 副本/","link":"","permalink":"https://btreenewbee.github.io/2021/02/03/%E5%A4%9A%E5%86%99%E7%82%B9%E5%B0%91%E5%86%99%E7%82%B9%E5%A4%9A%E5%B0%91%E5%86%99%E7%82%B9%20-%20%E5%89%AF%E6%9C%AC/","excerpt":"","text":"11111111","categories":[],"tags":[]},{"title":"我的龟龟的博客","slug":"我的龟龟的博客","date":"2021-01-08T12:48:23.000Z","updated":"2021-01-08T12:52:45.729Z","comments":true,"path":"2021/01/08/我的龟龟的博客/","link":"","permalink":"https://btreenewbee.github.io/2021/01/08/%E6%88%91%E7%9A%84%E9%BE%9F%E9%BE%9F%E7%9A%84%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"龟牌云开发的博客","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-01-07T16:32:11.218Z","updated":"2021-01-07T16:32:11.218Z","comments":true,"path":"2021/01/08/hello-world/","link":"","permalink":"https://btreenewbee.github.io/2021/01/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"SSL\\TLS","slug":"SSL-TLS","permalink":"https://btreenewbee.github.io/tags/SSL-TLS/"},{"name":"HTTPS","slug":"HTTPS","permalink":"https://btreenewbee.github.io/tags/HTTPS/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://btreenewbee.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"密码学","slug":"密码学","permalink":"https://btreenewbee.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]}